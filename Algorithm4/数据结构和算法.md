## 数据结构和算法

### 底层数据结构一般就两种，数组和链表。数组可迭代，链表兼具迭代和递归。

- 数组连续存储，访问方便，但是需要考虑扩容问题，在后面插入方便，在中间插入不方便。

```c#
void traverse(int arr[]){
    for(i=0;i<arr.length;i++){
        // 迭代访问arr[i]
    }
}
```

- 链表不连续，没有扩容问题，插入容易，访问困难，并且因为要存储指针需要额外消耗内存。

```c#
void traverse(ListNode head){
    for(ListNode p=head;p!=null;p=p.next){
        // 迭代访问p.val
    }
}
```

```c#
void traverse(ListNode head){
    // 前序遍历 root.val
    traverse(head.next);
    // 后续遍历 root.val
}
```

### 动态规划和回溯算法等其他算法的基础都是树的遍历，所以要学好算法，先掌握二叉树的遍历，培养算法思维

```c#
// 二叉树
void traverse(TreeNode root){
    // 前序遍历
    traverse(root.left);
    // 中序遍历
    traverse(root.right);
    // 后续遍历
}
```

```c#
// n叉树
void traverse(TreeNode root){
    foreach(TreeNode child in root.Children){
        traverse(child);
    }
}
```

### 最基础的排序算法

#### 选择排序

- 每次循环找到最小的放在最前面

- 运行状态和初始状态无关，即使初始状态是有序的，任然需要全部的时间

- 交换的次数是最小的

#### 插入排序

- 每次循环都能把指针之前的子数字排成有序的，思想和打扑克牌类似
- 显然它的比较次数变少了，交换次数变多了
- 如果初始是有序的，只需要一次遍历就好了

#### 希尔排序——改进的插入排序

- 希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 h 有序数组。

- 希尔排序改变了插排的步长，使每次交换都能与更远地方的元素比较，容易形成小范围内的有序。如果 h 很大，我们就能将元素移动到很远的地方，为实现更小的 h 有序创造方便。

- 对于任意以 1 结尾的 h 序列，我们都能够将数组排序

- 步长一般选择 1，4，13，40

  ```c#
  int N = a.length;
  int h = 1;
  while(h<N/3) h=3*h+1; // 1, 4, 13, 40, 121, 364, 1093, ... 
  while(h>=1){ // 将数组变成 h有序
      for(i=h;i<N;i++){
          // 插入排序...
      }
      // 改变h有序的长度，小于1时说明已经排完了
      h=h/3
  }
  ```

- 对于一般排序任务都可以使用希尔排序，他的事件复杂度虽然还是o(n^2)，但是在其实际时间已经非常接近（常数级别差距，来源：《算法4》）下面的排序方法了。当评估确实需要进一步提升性能时，可以改变成以下几种算法

#### 归并排序

- 先使左右两边有序，最后在“并”在一起。

- 当左右两边都只有一个元素时，或者不足一个元素时，直接并就可以了。由此可见，“并”才是重点。剩下的只要交给递归就好了。

  ```c#
  // “并”算法
  void merge(IComparable[] a,int lo,int mid,int hi){
      int i=lo,j=mid+1;
      
      // “并”算法 需要额外的空间，先复制一份出来
      IComparable[] aux=new IComparable[a.length];
      for(int k=0;k<=hi;k++){
          aux[i]=a[i];
      }
      
      // 并
      for(int k=lo;k<=hi;k++){
          if(i>mid){		// 左边用光了，用右边的，右边指针前进
              a[k]=aux[j++];
          }else if(j>hi){ // 右边用光了，有左边的，左边指针前进
              a[k]=aux[i++];
          }else if(less(aux[j],aux[i])){
              // 两边都没用光，谁小用谁，用谁谁指针前进
              a[k]=aux[j++];
          }else{
              a[k]=aux[i++];
          }
      }
  }
  ```

- 优化的思路

  - 一般使用归并处理到比较小的（比如长度小于15），一般使用插入排序处理。
  - 如果a[mid]比a[mid+1]小，说明左边最大的都比右边最小的小，说明这一段已经有序了，不用再“并”了
  - 可以想办法节省复制到辅助数组的时间（空间不能省），具体做法是，在递归调用的每个层次交换辅助数组和排序数组的角色。

#### 快速排序

- 先在一个点切分数组，使得前面的子数组都比它小，后面的子数组都比他大

- 递归解决左右两个子数组，由此看来，“切分”算法是快速排序的关键

  ```c#
  int partition(IComparable[] a,int lo,int hi){
      // 将数组切分为 a[lo...i-1] a[i] a[i+1...hi]
      int i=lo,j=hi+1;		// 左右两个扫描指针
      IComparable v=a[lo];	// 切分元素
      while(true){
          // 扫描左右，检查扫描是否结束并交换元素
          while(less(a[++i],v)){
              if(i==hi){
                  break;
              }
          }
          while(less(v,a[--j])){
              if(j==lo){
                  break;
              }
          }
          // 直到两个指针相遇，说明以v为切分点，左侧都比v小，右侧都比v大
          // 而此时，切分点正好是有指针j!!
          if(i>=j){
              break;
          }
          // 交换后可以保证左指针左侧都比v小，右指针右侧都比v大
          exchange(a,i,j);
      }
      exchange(a,lo,j);
      return j;
  }
  ```

  - 小心数组越界，需要特别注意数组中与切分点值相同的其他元素
  - 虽然他的比较次数多，但是交换次数小，比递归更快。但是对于小数组，他比插入排序要慢
  - 优化思路
    - 在递归到小数组时切换到插入排序（这点和归并优化思路一致）
    - 三取样切分，分别对应大于、等于、小于切分点元素的数组元素(使用与重复元素较多的情况)

  ```c#
  void sort(IComparable[] a,int lo,int hi){
  	if(hi<=lo)return;
      // 三个指针
      int lt=lo,i=lo+1,gt=hi;
      IComparable v=a[lo];
      while(i<=gt){
          int cmp=a[i].compareTo(v);
          if(cmp<0){
              exchange(a,lt++,i++);
          }
          else if(cmp>0){
              exchange(a,i,gt--);
          }
          else{
              i++;
          }
      }
      sort(a,lo,lt-1);
      // 中间的都是相等的，不用排了
      sort(a,gt+1,hi);
  }
  ```

#### 优先队列

- 最重要的操作就是**插入元素**和**删除最大元素**


- 使用二叉堆实现，注意二叉堆的第0个元素是不使用的

```c#
// 某个节点上浮使得堆有序
void swim(int k){
    // 当一个节点k比他的父节点k/2还大时，交换它和它的父节点，
    // 直到遇到一个更大的父节点，或者已经到达顶部
    while(k>1&&less(k/2,k)){
        exchage(k/2,k);
        k=k/2
    }
}
```

```c#
// 某个节点下沉使得堆有序
void sink(int k){
    while(2*k<=N){	// 注意判断条件
        int j=2*k;
        // j j+1 都是 k 的子节点
        if( j<N && less(j,j+1)){
            j++;	// 保证 j 指向两个子节点中较大的
        }
        // 如果k比j大，就不需要再下沉了
        if(!less(k,j)){
            break;
        }
        // 否则，需要继续下沉
        exchange(k,j);
        k=j;
    }
    
}
```

- 使用二叉堆构建优先队列就非常容易，如果要插入元素，直接再数组最后插入元素，在上浮再合适的位置；如果要删除最大元素，让最后一个元素和第一个元素交换，然后将第一个元素下沉到合适的位置。

#### 堆排序

- 就是构造优先队列的过程